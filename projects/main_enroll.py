import os
script_dir = os.path.dirname(os.path.abspath(__file__))
os.chdir(script_dir)

import json
import uuid
import customtkinter as ctk
from tkinter import messagebox
from PIL import Image
from customtkinter import CTkImage
from datetime import datetime, timezone, timedelta, time as dt_time, date as dt_date
import io
import base64
import calendar
import requests

import face_enroll
import fingerprint_enroll
from mqtt_enroll import MQTTEnrollManager, generate_hashed_password # Import generate_hashed_password
import database_enroll
import rfid_enroll

try:
    from pyfingerprint.pyfingerprint import PyFingerprint
except ImportError:
    PyFingerprint = None
except Exception as e: 
    if "DEBUG" in globals() and DEBUG: print(f"[Enroll PYFINGERPRINT IMPORT ERROR] {e}")
    PyFingerprint = None

try:
    import board
    import busio
    from adafruit_pn532.i2c import PN532_I2C
except ImportError:
    PN532_I2C = None
    board = None
    busio = None
except Exception as e_pn532_import: 
    if "DEBUG" in globals() and DEBUG: print(f"[Enroll PN532 IMPORT ERROR] {e_pn532_import}")
    PN532_I2C = None
    board = None
    busio = None

DEBUG = True
BG_COLOR = "#F0F0F0"
SCREEN_BG_COLOR = "#E0E0E0"
ACCENT_COLOR = "#007AFF"
BUTTON_FG_TEXT = "#FFFFFF"
SUCCESS_COLOR = "#34C759"
WARNING_COLOR = "#FF9500"
ERROR_COLOR = "#FF3B30"

TITLE_FONT = ("Segoe UI", 26, "bold")
STEP_TITLE_FONT = ("Segoe UI", 22, "bold")
LABEL_FONT = ("Segoe UI", 16)
INPUT_FONT = ("Segoe UI", 16)
BUTTON_FONT = ("Segoe UI", 18, "bold")
SMALL_STATUS_FONT = ("Segoe UI", 13)
OPTION_MENU_FONT = ("Segoe UI", 15)
OPTION_MENU_DROPDOWN_FONT = ("Segoe UI", 14)

LARGE_BUTTON_WIDTH = 250
MEDIUM_BUTTON_WIDTH = 180
LARGE_BUTTON_HEIGHT = 65
MEDIUM_BUTTON_HEIGHT = 50
ENTRY_HEIGHT = 42
OPTION_MENU_HEIGHT = 42
OPTION_MENU_WIDTH_S = 75
OPTION_MENU_WIDTH_M = 100

icon_size_large_button_step2 = (200, 200)
img_size_status = (28, 28)
icon_size_nav_button = (20,20)
icon_size_send_button = (30,30)

PAD_X_MAIN_CONTAINER = 20
PAD_Y_MAIN_CONTAINER = 15
PAD_X_SECTION = 12
PAD_Y_SECTION = 8
PAD_X_WIDGET_HORIZONTAL = 5
PAD_Y_WIDGET_VERTICAL = 4

WINDOW_WIDTH = 1024
WINDOW_HEIGHT = 600

CONFIG_FILE = "mqtt_enroll_config.json"
HEALTHCHECK_INTERVAL_MS = 10000

FINGERPRINT_PORT = '/dev/ttyAMA4'
FINGERPRINT_BAUDRATE = 57600
RFID_RESET_PIN_BCM = None
RFID_IRQ_PIN_BCM = None
GMT_PLUS_7 = timezone(timedelta(hours=7))

def get_hour_values(): return [f"{h:02d}" for h in range(24)]
def get_minute_second_values(): return [f"{m:02d}" for m in range(60)]
def get_year_values(start_offset=-2, end_offset=5):
    current_year = datetime.now().year
    return [str(y) for y in range(current_year + start_offset, current_year + end_offset + 1)]
def get_month_values(): return [f"{m:02d}" for m in range(1, 13)]
def get_day_values(year_str, month_str):
    try:
        year = int(year_str); month = int(month_str)
        num_days = calendar.monthrange(year, month)[1]
        return [f"{d:02d}" for d in range(1, num_days + 1)]
    except (ValueError, TypeError): return [f"{d:02d}" for d in range(1, 32)]

def get_mac_address():
    mac = uuid.getnode()
    return ':'.join(("%012X" % mac)[i:i+2] for i in range(0, 12, 2))

def load_image_ctk(path, size):
    try:
        full_path = os.path.join(script_dir, path)
        if not os.path.exists(full_path):
            if DEBUG: print(f"[Load Image WARN] Image file not found: {full_path}"); return None
        img = Image.open(full_path)
        if size: img.thumbnail(size, Image.Resampling.LANCZOS)
        return CTkImage(light_image=img, dark_image=img, size=img.size)
    except Exception as e:
        if DEBUG: print(f"[Load Image ERROR] Failed to load {path}: {e}"); return None

class EnrollmentApp:
    def __init__(self, root):
        self.root = root
        self.enroll_mac = get_mac_address()
        if DEBUG: print("[Enroll DEBUG] Enrollment Device MAC Address:", self.enroll_mac)

        try: database_enroll.initialize_database()
        except Exception as e_db:
            messagebox.showerror("Database Error", f"Failed to initialize database: {e_db}\nApplication will exit."); root.quit(); return

        self.discovered_rooms_macs = database_enroll.get_all_discovered_devices()
        if DEBUG: print(f"[Enroll DEBUG] Loaded initially discovered rooms/devices: {self.discovered_rooms_macs}")

        self.current_bio_id = None; self.current_id_number = ""; self.current_person_name = ""; self.current_room_name_selected = None
        now = datetime.now()
        self.from_hour_str = "00"; self.from_minute_str = "00"; self.from_second_str = "00"
        self.from_day_str = now.strftime("%d"); self.from_month_str = now.strftime("%m"); self.from_year_str = now.strftime("%Y")
        to_dt = now + timedelta(days=6)
        self.to_hour_str = "23"; self.to_minute_str = "59"; self.to_second_str = "59"
        self.to_day_str = to_dt.strftime("%d"); self.to_month_str = to_dt.strftime("%m"); self.to_year_str = to_dt.strftime("%Y")
        self.active_day_mask_list = [True] * 7

        self.current_face_image_b64 = None; 
        self.current_face_template_b64 = None
        self.current_finger_imgage_b64 = "/9j/4AAQSkZJRgABAQEBLAEsAAD/4QBWRXhpZgAATU0AKgAAAAgABAEaAAUAAAABAAAAPgEbAAUAAAABAAAARgEoAAMAAAABAAIAAAITAAMAAAABAAEAAAAAAAAAAAEsAAAAAQAAASwAAAAB/+0ALFBob3Rvc2hvcCAzLjAAOEJJTQQEAAAAAAAPHAFaAAMbJUccAQAAAgAEAP/hDIFodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvADw/eHBhY2tldCBiZWdpbj0n77u/JyBpZD0nVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkJz8+Cjx4OnhtcG1ldGEgeG1sbnM6eD0nYWRvYmU6bnM6bWV0YS8nIHg6eG1wdGs9J0ltYWdlOjpFeGlmVG9vbCAxMC4xMCc+CjxyZGY6UkRGIHhtbG5zOnJkZj0naHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyc+CgogPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9JycKICB4bWxuczp0aWZmPSdodHRwOi8vbnMuYWRvYmUuY29tL3RpZmYvMS4wLyc+CiAgPHRpZmY6UmVzb2x1dGlvblVuaXQ+MjwvdGlmZjpSZXNvbHV0aW9uVW5pdD4KICA8dGlmZjpYUmVzb2x1dGlvbj4zMDAvMTwvdGlmZjpYUmVzb2x1dGlvbj4KICA8dGlmZjpZUmVzb2x1dGlvbj4zMDAvMTwvdGlmZjpZUmVzb2x1dGlvbj4KIDwvcmRmOkRlc2NyaXB0aW9uPgoKIDxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PScnCiAgeG1sbnM6eG1wTU09J2h0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8nPgogIDx4bXBNTTpEb2N1bWVudElEPmFkb2JlOmRvY2lkOnN0b2NrOjg0ZWNlODNhLTY2Y2UtNGZlYS04MDNiLTkyZjgxYWFiNGM1OTwveG1wTU06RG9jdW1lbnRJRD4KICA8eG1wTU06SW5zdGFuY2VJRD54bXAuaWlkOjg0MGFmZDQ4LWJkYjMtNDA1Ny1hN2I4LWNlYjZlNjAyZDRjYjwveG1wTU06SW5zdGFuY2VJRD4KIDwvcmRmOkRlc2NyaXB0aW9uPgo8L3JkZjpSREY+CjwveDp4bXBtZXRhPgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAo8P3hwYWNrZXQgZW5kPSd3Jz8+/9sAQwADAgIDAgIDAwMDBAMDBAUIBQUEBAUKBwcGCAwKDAwLCgsLDQ4SEA0OEQ4LCxAWEBETFBUVFQwPFxgWFBgSFBUU/9sAQwEDBAQFBAUJBQUJFA0LDRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQU/8AAEQgA8ACsAwERAAIRAQMRAf/EAB0AAAEEAwEBAAAAAAAAAAAAAAAEBQYHAgMIAQn/xAA6EAABBAIBBAEDAwMCAwgDAQABAgMEBQYREgAHEyEiFBUxCCNBFjJRQmEkM3ElJjRDRFJi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"
        self.current_finger_template_b64 = None; 
        self.current_rfid_uid_str = None
        self.preview_face_image_ctk = None

        self.fetched_schedule_data = None
        self.current_cccd_for_schedule = ""

        self.http_api_token = None
        self.http_api_token_expiry = None

        self.mqtt_manager = None; self.mqtt_config = {}
        self.config_path = os.path.join(script_dir, CONFIG_FILE)
        self.screen_history = []

        self.fingerprint_sensor = None; self.rfid_sensor = None

        self.connection_status_label = None; self.bg_label = None
        self.main_frame = None; self.config_btn_ref = None
        self.nav_frame = None

        self.connected_image = load_image_ctk("images/connected.jpg", img_size_status)
        self.disconnected_image = load_image_ctk("images/disconnected.jpg", img_size_status)
        self.bg_photo = load_image_ctk("images/background_enroll.jpeg", (WINDOW_WIDTH, WINDOW_HEIGHT))
        self.face_icon_large = load_image_ctk("images/face.png", icon_size_large_button_step2)
        self.fingerprint_icon_large = load_image_ctk("images/fingerprint.png", icon_size_large_button_step2)
        self.rfid_icon_large = load_image_ctk("images/rfid.png", icon_size_large_button_step2)
        self.next_icon = load_image_ctk("images/next_arrow.png", icon_size_nav_button)
        self.back_icon = load_image_ctk("images/back_arrow.png", icon_size_nav_button)
        self.send_icon_large = load_image_ctk("images/send.png", icon_size_send_button)

        self.root.configure(fg_color=BG_COLOR)
        self.show_background()
        self.connection_status_label = ctk.CTkLabel(root, image=self.disconnected_image, text="Chưa kết nối MQTT", font=("Segoe UI", 10), text_color=ERROR_COLOR, compound="left")
        self.connection_status_label.place(relx=0.01, rely=0.98, anchor="sw")
        self.create_config_button()

        self.initialize_fingerprint_sensor()
        self.initialize_rfid_sensor()

        if os.path.exists(self.config_path):
            try:
                with open(self.config_path, "r") as f: self.mqtt_config = json.load(f)
                if not self.mqtt_config.get("broker") or not self.mqtt_config.get("port") or not self.mqtt_config.get("http_port"):
                     if DEBUG: print("[Enroll WARN] MQTT/API config file missing 'broker', 'port', or 'http_port'.")
                     raise ValueError("Config missing broker/port/http_port.")
                self._create_and_init_mqtt_manager()
                self.start_new_enrollment_process()
            except Exception as e_cfg_load:
                if DEBUG: print(f"[Enroll ERROR] Failed to load MQTT/API config or initialize: {e_cfg_load}.")
                if os.path.exists(self.config_path):
                    try: os.remove(self.config_path); self.mqtt_config = {}
                    except OSError as e_rm_cfg: print(f"[Enroll ERROR] Failed removing invalid config file: {e_rm_cfg}")
                self.push_screen("mqtt_config", self.build_mqtt_config_screen)
        else:
            if DEBUG: print(f"[Enroll INFO] MQTT/API config file '{self.config_path}' not found. Navigating to config screen.")
            self.push_screen("mqtt_config", self.build_mqtt_config_screen)

        self.schedule_healthcheck_only()
        self.root.protocol("WM_DELETE_WINDOW", self.cleanup)

    def _fetch_or_refresh_http_api_token(self, force_refresh=False):
        if self.http_api_token and not force_refresh:
            if self.http_api_token_expiry and datetime.now(timezone.utc) < self.http_api_token_expiry:
                if DEBUG: print("[Enroll DEBUG] Using existing valid HTTP API token.")
                return self.http_api_token
            elif not self.http_api_token_expiry:
                 if DEBUG: print("[Enroll DEBUG] Using existing HTTP API token (no expiry info).")
                 return self.http_api_token

        if not self.mqtt_config.get('broker') or not self.mqtt_config.get('http_port'):
            if DEBUG: print("[Enroll ERROR] API server config (broker/http_port) missing for fetching HTTP API token.")
            messagebox.showerror("Lỗi Cấu Hình", "Cấu hình server API (broker, http_port) bị thiếu.", parent=self.root)
            return None

        api_host_base = self.mqtt_config['broker'].strip().rstrip('/')
        if not api_host_base.startswith(('http://', 'https://')):
            api_host_base = f"http://{api_host_base}"
        api_port = self.mqtt_config['http_port']

        token_url = f"{api_host_base}:{api_port}/api/devicecomm/gettoken"
        
        payload = {"macAddress": self.enroll_mac, "password": generate_hashed_password(self.enroll_mac)}
        
        if DEBUG: print(f"[Enroll DEBUG] Fetching HTTP API token from: {token_url} with payload: {payload}")

        try:
            response = requests.post(token_url, json=payload, timeout=10)
            response.raise_for_status()
            token_data_response = response.json()
            if DEBUG: print(f"[Enroll DEBUG] HTTP API token raw response: {token_data_response}")

            if isinstance(token_data_response, dict):
                if token_data_response.get("code") == "OK" and "data" in token_data_response:
                    data_field = token_data_response["data"]
                    self.http_api_token = data_field.get("token")
                    expires_in_seconds = data_field.get("expiresIn")
                    if expires_in_seconds:
                        try:
                            self.http_api_token_expiry = datetime.now(timezone.utc) + timedelta(seconds=int(expires_in_seconds) - 60)
                            if DEBUG: print(f"[Enroll DEBUG] HTTP API token will expire around: {self.http_api_token_expiry}")
                        except ValueError:
                             if DEBUG: print(f"[Enroll WARN] Invalid expiresIn value: {expires_in_seconds}")
                             self.http_api_token_expiry = None
                elif "accessToken" in token_data_response:
                    self.http_api_token = token_data_response.get("accessToken")
                    expires_in_seconds = token_data_response.get("expiresIn")
                    if expires_in_seconds:
                        try:
                            self.http_api_token_expiry = datetime.now(timezone.utc) + timedelta(seconds=int(expires_in_seconds) - 60)
                            if DEBUG: print(f"[Enroll DEBUG] HTTP API token (accessToken) will expire around: {self.http_api_token_expiry}")
                        except ValueError:
                            if DEBUG: print(f"[Enroll WARN] Invalid expiresIn value for accessToken: {expires_in_seconds}")
                            self.http_api_token_expiry = None
            
            if self.http_api_token:
                if DEBUG: print(f"[Enroll DEBUG] Successfully fetched/refreshed HTTP API token: {self.http_api_token[:20]}...")
                return self.http_api_token
            else:
                if DEBUG: print(f"[Enroll ERROR] 'token' or 'accessToken' not found in HTTP API token response from {token_url}. Response: {token_data_response}")
                messagebox.showerror("Lỗi Lấy Token API", f"Không tìm thấy token trong phản hồi từ server: {str(token_data_response)[:200]}", parent=self.root)
                return None

        except requests.exceptions.HTTPError as http_err:
            err_msg = f"Lỗi HTTP {http_err.response.status_code if http_err.response else 'N/A'} khi lấy token API: {http_err}"
            response_text = http_err.response.text[:200] if http_err.response else "N/A"
            if DEBUG: print(f"[Enroll ERROR] {err_msg} - Response: {response_text}")
            messagebox.showerror("Lỗi API Token", f"{err_msg}\nNội dung: {response_text}", parent=self.root)
        except requests.exceptions.RequestException as req_err:
            if DEBUG: print(f"[Enroll ERROR] Request exception fetching HTTP API token: {req_err}")
            messagebox.showerror("Lỗi Mạng API Token", f"Lỗi kết nối khi lấy token API: {req_err}", parent=self.root)
        except json.JSONDecodeError:
            response_text = response.text[:200] if 'response' in locals() and hasattr(response, 'text') else "N/A"
            if DEBUG: print(f"[Enroll ERROR] JSON decode error fetching HTTP API token. Response: {response_text}")
            messagebox.showerror("Lỗi Dữ Liệu API Token", f"Phản hồi lấy token API không phải JSON hợp lệ.\nNội dung: {response_text}", parent=self.root)
        except Exception as e:
            if DEBUG: print(f"[Enroll ERROR] Unexpected error fetching HTTP API token: {e}")
            messagebox.showerror("Lỗi Không Xác Định (API Token)", f"Lỗi khi lấy token API: {e}", parent=self.root)
        
        return None

    def _extract_person_name_from_schedule(self, schedule_name_api):
        if not schedule_name_api:
            return ""
        if " - " in schedule_name_api:
            return schedule_name_api.split(" - ")[0].strip()
        return schedule_name_api.strip()

    def action_fetch_schedule(self):
        cccd = self.cccd_entry_s0.get().strip()
        if not cccd:
            messagebox.showerror("Thiếu thông tin", "Vui lòng nhập số CCCD.", parent=self.main_frame or self.root)
            return

        self.current_cccd_for_schedule = cccd

        if not self.mqtt_config.get('broker') or not self.mqtt_config.get('http_port'):
            messagebox.showerror("Lỗi cấu hình", "Chưa cấu hình API server (trong file mqtt_enroll_config.json).", parent=self.main_frame or self.root)
            return

        api_host_base = self.mqtt_config['broker'].strip().rstrip('/')
        if not api_host_base.startswith(('http://', 'https://')):
            api_host_base = f"http://{api_host_base}"
        api_port = self.mqtt_config['http_port']
        
        access_token = self._fetch_or_refresh_http_api_token()

        if not access_token:
            current_screen_id = self.screen_history[-1][0] if self.screen_history else None
            if hasattr(self, 'fetch_schedule_button_s0') and self.fetch_schedule_button_s0.winfo_exists() and current_screen_id == "step0_id_input":
                 self.fetch_schedule_button_s0.configure(text="KIỂM TRA LỊCH", state="normal")
            return

        headers = {
            "Authorization": f"Bearer {access_token}"
        }
        if DEBUG: print(f"[Enroll DEBUG] Request Headers for getschedule: {headers}")
        
        self.fetch_schedule_button_s0.configure(text="ĐANG TẢI...", state="disabled")
        self.root.update_idletasks()
        
        url = f"{api_host_base}:{api_port}/api/schedule/getschedule?idNumber={cccd}"
        if DEBUG: print(f"[Enroll DEBUG][API Call] Fetching schedule from (GET): {url}")
        
        try:
            response = requests.get(url, headers=headers, timeout=10)
            
            if DEBUG: print(f"[Enroll DEBUG][API Response Status] /getschedule: {response.status_code}")
            if response.status_code == 401 and DEBUG:
                print(f"[Enroll DEBUG][API Response 401 Content] /getschedule: {response.text[:500]}")

            response.raise_for_status() 
            
            response_wrapper = response.json()
            if DEBUG: print(f"[Enroll DEBUG][API Response] Full schedule wrapper: {json.dumps(response_wrapper, indent=2)}")

            if isinstance(response_wrapper, dict) and \
               response_wrapper.get("code") == "OK" and \
               "data" in response_wrapper and \
               isinstance(response_wrapper.get("data"), list):
                
                actual_schedule_list = response_wrapper["data"]
                if DEBUG: print(f"[Enroll DEBUG][API Response] Extracted 'data' field (list of schedules): {json.dumps(actual_schedule_list, indent=2)}")

                if not actual_schedule_list:
                    messagebox.showwarning("Không tìm thấy lịch", f"Không có lịch làm việc nào được tìm thấy cho CCCD: {cccd}.", parent=self.main_frame or self.root)
                    self.fetched_schedule_data = None
                else:
                    self.fetched_schedule_data = actual_schedule_list[0]
                    required_fields = ["idNumber", "scheduleId", "fromDate", "toDate", "fromTime", "toTime", "activeDays"]
                    if not all(field in self.fetched_schedule_data for field in required_fields):
                        messagebox.showerror("Lỗi Dữ Liệu Lịch", "Dữ liệu lịch làm việc từ server không đầy đủ. Vui lòng liên hệ quản trị.", parent=self.main_frame or self.root)
                        self.fetched_schedule_data = None
                    else:
                        messagebox.showinfo("Thành công", f"Đã tìm thấy lịch làm việc cho CCCD: {cccd}.\nTên lịch: {self.fetched_schedule_data.get('scheduleName', 'N/A')}", parent=self.main_frame or self.root)
                        self.current_id_number = self.fetched_schedule_data.get("idNumber", cccd)
                        
                        self.current_person_name = self._extract_person_name_from_schedule(self.fetched_schedule_data.get("scheduleName", ""))
                        if DEBUG: print(f"[Enroll DEBUG] Auto-assigned Person Name: {self.current_person_name}")

                        try:
                            from_date_api = self.fetched_schedule_data.get("fromDate", "").split("T")[0]
                            to_date_api = self.fetched_schedule_data.get("toDate", "").split("T")[0]
                            from_time_api = self.fetched_schedule_data.get("fromTime", "00:00:00")
                            to_time_api = self.fetched_schedule_data.get("toTime", "23:59:59")
                            
                            if from_date_api: self.from_year_str, self.from_month_str, self.from_day_str = from_date_api.split("-")
                            if from_time_api: self.from_hour_str, self.from_minute_str, self.from_second_str = from_time_api.split(":")
                            if to_date_api: self.to_year_str, self.to_month_str, self.to_day_str = to_date_api.split("-")
                            if to_time_api: self.to_hour_str, self.to_minute_str, self.to_second_str = to_time_api.split(":")

                            active_days_str_api = self.fetched_schedule_data.get("activeDays", "0000000")
                            if len(active_days_str_api) == 7:
                                self.active_day_mask_list = [char == '1' for char in active_days_str_api]
                            else:
                                self.active_day_mask_list = [False] * 7
                        except Exception as e_auto_assign_dt:
                            if DEBUG: print(f"[Enroll WARN] Could not auto-assign datetime from schedule: {e_auto_assign_dt}")
                        
                        if not self.current_bio_id: self.generate_new_bio_id()
                        
                        self.push_screen("step2_biometrics", self.show_step2_biometric_screen)
                        return 
            else:
                error_msg_structure = "Cấu trúc phản hồi từ API lấy lịch không như mong đợi."
                if isinstance(response_wrapper, dict):
                    error_msg_structure += f" Code: {response_wrapper.get('code')}, Message: {response_wrapper.get('message')}"
                if DEBUG: print(f"[Enroll ERROR] {error_msg_structure}. Response: {response_wrapper}")
                messagebox.showerror("Lỗi Dữ Liệu API", error_msg_structure, parent=self.main_frame or self.root)
                self.fetched_schedule_data = None

        except requests.exceptions.HTTPError as http_err:
            err_msg = f"Lỗi HTTP {http_err.response.status_code if http_err.response else 'N/A'} khi lấy lịch: {http_err}."
            try: 
                err_detail = http_err.response.json()
                err_msg += f"\nChi tiết server: {err_detail.get('message', str(err_detail))}"
            except json.JSONDecodeError:
                err_msg += f"\nNội dung phản hồi (không phải JSON): {http_err.response.text[:200] if http_err.response else ''}"
            except Exception: pass
            messagebox.showerror("Lỗi API", err_msg, parent=self.main_frame or self.root)
            self.fetched_schedule_data = None
        except requests.exceptions.RequestException as req_err: 
            messagebox.showerror("Lỗi Mạng", f"Lỗi kết nối khi lấy lịch: {req_err}", parent=self.main_frame or self.root)
            self.fetched_schedule_data = None
        except json.JSONDecodeError:
            messagebox.showerror("Lỗi Dữ Liệu", "Phản hồi từ API lấy lịch không phải là JSON hợp lệ.", parent=self.main_frame or self.root)
            self.fetched_schedule_data = None
        except Exception as e: 
            messagebox.showerror("Lỗi không xác định", f"Đã xảy ra lỗi khi xử lý lịch làm việc: {e}", parent=self.main_frame or self.root)
            self.fetched_schedule_data = None
        finally:
            current_screen_id = self.screen_history[-1][0] if self.screen_history else None
            if hasattr(self, 'fetch_schedule_button_s0') and self.fetch_schedule_button_s0.winfo_exists() and \
               (current_screen_id == "step0_id_input" and not self.fetched_schedule_data):
                 self.fetch_schedule_button_s0.configure(text="KIỂM TRA LỊCH", state="normal")

    def prepare_and_send_data_http(self):
        parent_for_messages = self.main_frame or self.root

        if not self.fetched_schedule_data:
            messagebox.showerror("Lỗi Dữ Liệu", "Thiếu thông tin lịch làm việc đã lấy từ server. Không thể gửi.", parent=parent_for_messages)
            self._action_goto_step0_from_step3()
            return

        if not self.current_person_name: # Person name is now auto-assigned but could be empty if scheduleName was empty
            # You might want to allow editing person_name in Step 2 or 3 if it's critical and can be empty from API
            messagebox.showerror("Lỗi Thiếu Thông Tin", "Tên người dùng không được để trống.", parent=parent_for_messages)
            # Consider navigating to a point where name can be fixed, or make it editable in Step 2/3
            return


        if not (self.current_face_template_b64 or self.current_finger_template_b64 or self.current_rfid_uid_str):
            messagebox.showwarning("Lỗi Thiếu Sinh Trắc Học", "Cần đăng ký ít nhất một mẫu sinh trắc học (tại Bước 2).", parent=parent_for_messages)
            self._action_goto_step2_from_step3()
            return

        access_token = self._fetch_or_refresh_http_api_token() 

        if not access_token:
            return

        upload_headers = {
            "Authorization": f"Bearer {access_token}",
            "Content-Type": "application/json"
        }
        if DEBUG: print(f"[Enroll DEBUG] Request Headers for visitorbio/upload: {upload_headers}")
        
        face_img_payload_list = []
        if self.current_face_template_b64 and self.current_face_image_b64:
            face_img_payload_list.append({"Img": self.current_face_image_b64, "Template": self.current_face_template_b64})

        finger_img_payload_list = []
        if self.current_finger_template_b64:
            finger_img_payload_list.append({"Img": self.current_finger_imgage_b64, "Template": self.current_finger_template_b64})
            
        id_card_uid_list = []
        if self.current_rfid_uid_str:
            uid_raw = self.current_rfid_uid_str.encode("utf-8")  
            uid_base64 = base64.b64encode(uid_raw).decode("utf-8")
            id_card_uid_list.append({"Img": "", "Template": uid_base64})

        http_payload = {
            "idNumber": self.fetched_schedule_data.get("idNumber"),
            "ScheduleId": self.fetched_schedule_data.get("scheduleId"),
            "FaceImg": face_img_payload_list,
            "FingerImg": finger_img_payload_list,
            "IrisImg": id_card_uid_list,
            "CaptureTime": datetime.now(GMT_PLUS_7).isoformat(timespec='milliseconds'),
            "CreatedBy": self.enroll_mac
        }

        if not self.mqtt_config.get('broker') or not self.mqtt_config.get('http_port'):
            messagebox.showerror("Lỗi cấu hình", "Chưa cấu hình API server (trong file mqtt_enroll_config.json).", parent=parent_for_messages)
            return

        api_host_base = self.mqtt_config['broker'].strip().rstrip('/')
        if not api_host_base.startswith(('http://', 'https://')):
            api_host_base = f"http://{api_host_base}"
        api_port = self.mqtt_config['http_port']

        upload_url = f"{api_host_base}:{api_port}/api/visitorbio/upload"
        if DEBUG: print(f"[Enroll DEBUG][API Call] Sending bio data to: {upload_url} with payload (first 500 chars): {json.dumps(http_payload)[:500]}...")

        try:
            response = requests.post(upload_url, json=http_payload, headers=upload_headers, timeout=30)
            response.raise_for_status()

            response_data = response.json()
            if DEBUG: print(f"[Enroll DEBUG][API Response] Upload response: {response_data}")

            if response_data.get("code") == "OK":
                messagebox.showinfo("Gửi Thành Công",
                                    f"Đã gửi dữ liệu đăng ký cho '{self.current_person_name}' (ID: {http_payload['idNumber']}) lên server.\n{response_data.get('message', 'Thao tác thành công.')}",
                                    parent=self.root)
                self.start_new_enrollment_process()
            else:
                messagebox.showerror("Lỗi Từ Server",
                                     f"Server báo lỗi khi gửi dữ liệu: {response_data.get('message', 'Không có thông báo lỗi cụ thể.')}\n(Code: {response_data.get('code')})",
                                     parent=self.root)

        except requests.exceptions.HTTPError as http_err:
            err_msg = f"Lỗi HTTP {http_err.response.status_code if http_err.response else 'N/A'} khi gửi dữ liệu: {http_err}."
            try: 
                err_detail = http_err.response.json()
                err_msg += f"\nChi tiết server: {err_detail.get('message', str(err_detail))}"
            except json.JSONDecodeError:
                err_msg += f"\nNội dung phản hồi (không phải JSON): {http_err.response.text[:200] if http_err.response else ''}"
            except Exception: pass
            messagebox.showerror("Lỗi API", err_msg, parent=parent_for_messages)
        except requests.exceptions.RequestException as req_err:
            messagebox.showerror("Lỗi Mạng", f"Lỗi kết nối khi gửi dữ liệu: {req_err}", parent=parent_for_messages)
        except json.JSONDecodeError:
            messagebox.showerror("Lỗi Dữ Liệu", "Phản hồi từ API gửi dữ liệu không phải là JSON hợp lệ.", parent=parent_for_messages)
        except Exception as e:
            messagebox.showerror("Lỗi không xác định", f"Đã xảy ra lỗi khi gửi dữ liệu: {e}", parent=parent_for_messages)

    # --- Các hàm còn lại của EnrollmentApp giữ nguyên như file gốc ---
    # --- Đảm bảo bạn copy đầy đủ các hàm đó vào đây ---

    def _create_and_init_mqtt_manager(self):
        if self.mqtt_config:
            if self.mqtt_manager:
                self.mqtt_manager.disconnect_client(explicit=True)

            if DEBUG: print("[Enroll DEBUG] Creating and initializing MQTTManager with config:", self.mqtt_config)
            self.mqtt_manager = MQTTEnrollManager(
                mqtt_config=self.mqtt_config,
                enroll_mac=self.enroll_mac,
                config_file_path=self.config_path,
                debug=DEBUG
            )
            self.mqtt_manager.on_connection_status_change = self.update_connection_status
            self.mqtt_manager.on_device_info_received = self.handle_discovered_device_info
            self.mqtt_manager.attempt_connection_sequence()

    def generate_new_bio_id(self):
        self.current_bio_id = uuid.uuid4().hex[:10].upper()
        if DEBUG: print(f"[Enroll DEBUG] New Client-Side Bio ID generated: {self.current_bio_id}")

    def initialize_fingerprint_sensor(self):
        if PyFingerprint is None:
            if DEBUG: print("[Enroll WARN] PyFingerprint library not available. Fingerprint functions disabled.")
            return
        try:
            self.fingerprint_sensor = PyFingerprint(FINGERPRINT_PORT, FINGERPRINT_BAUDRATE, 0xFFFFFFFF, 0x00000000)
            if not self.fingerprint_sensor.verifyPassword():
                if DEBUG: print("[Enroll ERROR] Fingerprint sensor password verification failed. Sensor might not be connected or accessible.")
                self.fingerprint_sensor = None
            elif DEBUG: print("[Enroll INFO] Fingerprint sensor verified successfully.")
        except Exception as e_fp_init:
            if DEBUG: print(f"[Enroll ERROR] Failed to initialize fingerprint sensor: {e_fp_init}")
            self.fingerprint_sensor = None

    def initialize_rfid_sensor(self):
        if PN532_I2C is None or board is None or busio is None:
            if DEBUG: print("[Enroll WARN] PN532 I2C libraries (board, busio, adafruit_pn532) not found. RFID functions disabled.")
            self.rfid_sensor = None; return
        try:
            i2c = busio.I2C(board.SCL, board.SDA)
            reset_pin_obj = irq_pin_obj = None
            if RFID_RESET_PIN_BCM is not None:
                import digitalio
                reset_pin_obj = digitalio.DigitalInOut(getattr(board, f"D{RFID_RESET_PIN_BCM}"))
            if RFID_IRQ_PIN_BCM is not None:
                import digitalio
                irq_pin_obj = digitalio.DigitalInOut(getattr(board, f"D{RFID_IRQ_PIN_BCM}"))

            self.rfid_sensor = PN532_I2C(i2c, debug=False, reset=reset_pin_obj, irq=irq_pin_obj)
            self.rfid_sensor.SAM_configuration()
            ic, ver, rev, support = self.rfid_sensor.firmware_version
            if DEBUG: print(f"[Enroll INFO] PN532 I2C sensor initialized. Firmware ver: {ver}.{rev}")
        except Exception as e_rfid_init:
            if DEBUG: print(f"[Enroll ERROR] Failed to initialize RFID I2C sensor: {e_rfid_init}")
            self.rfid_sensor = None

    def handle_discovered_device_info(self, room_name, mac_address):
        if room_name and mac_address:
            self.discovered_rooms_macs[room_name] = mac_address
            active_screen_id = self.screen_history[-1][0] if self.screen_history else None
            if active_screen_id == "step1_basic_info" and hasattr(self, 'room_name_option_menu_s1') and \
               self.room_name_option_menu_s1 and self.room_name_option_menu_s1.winfo_exists():
                new_room_options = sorted(list(self.discovered_rooms_macs.keys()))
                current_selection = self.room_name_var_s1.get()
                self.room_name_option_menu_s1.configure(values=new_room_options if new_room_options else ["(Chưa có phòng)"])
                if current_selection in new_room_options:
                    self.room_name_var_s1.set(current_selection)
                elif new_room_options:
                    self.room_name_var_s1.set(new_room_options[0])
                else:
                    self.room_name_var_s1.set("(Chưa có phòng)")
        elif DEBUG: print(f"[Enroll WARN] Received incomplete device info from MQTT: room='{room_name}', mac='{mac_address}'")

    def schedule_healthcheck_only(self):
        if self.mqtt_manager and self.mqtt_manager.is_actively_connected():
            self.mqtt_manager.send_healthcheck()
        if self.root and self.root.winfo_exists():
            self.root.after(HEALTHCHECK_INTERVAL_MS, self.schedule_healthcheck_only)

    def update_connection_status(self, is_connected):
        if not (hasattr(self,'connection_status_label') and self.connection_status_label and self.connection_status_label.winfo_exists()): return
        img_to_show = self.connected_image if is_connected else self.disconnected_image
        status_text = " Đã kết nối MQTT" if is_connected else " Mất kết nối MQTT"
        text_color = SUCCESS_COLOR if is_connected else ERROR_COLOR
        self.connection_status_label.configure(image=img_to_show, text=status_text, text_color=text_color)

    def show_background(self):
        if hasattr(self,'bg_photo') and self.bg_photo:
            if hasattr(self,'bg_label') and self.bg_label and self.bg_label.winfo_exists(): self.bg_label.destroy()
            self.bg_label = ctk.CTkLabel(self.root, image=self.bg_photo, text=""); self.bg_label.place(x=0, y=0, relwidth=1, relheight=1); self.bg_label.lower()

    def clear_frames(self, keep_background=True):
        if hasattr(self, 'main_frame') and self.main_frame and self.main_frame.winfo_exists():
            self.main_frame.destroy(); self.main_frame = None
        if hasattr(self, 'nav_frame') and self.nav_frame and self.nav_frame.winfo_exists():
            self.nav_frame.destroy(); self.nav_frame = None
        face_enroll.stop_face_capture()
        if keep_background:
            self.show_background()
            if hasattr(self, 'connection_status_label') and self.connection_status_label and self.connection_status_label.winfo_exists():
                 self.connection_status_label.lift()
            self.create_config_button()

    def push_screen(self, screen_id, screen_func, *args):
        if self.screen_history and self.screen_history[-1][0] == screen_id and not screen_id.startswith("step"):
            if DEBUG: print(f"[Enroll DEBUG] Screen '{screen_id}' already at top of history. Skipping push.")
            return
        self.screen_history.append((screen_id, screen_func, args))
        if DEBUG: print(f"[Enroll DEBUG] Pushing screen: {screen_id}. History: {[s[0] for s in self.screen_history]}")
        self.clear_frames()
        self.root.update_idletasks()
        screen_func(*args)

    def go_back(self):
        if len(self.screen_history) > 1:
            self.screen_history.pop()
            prev_screen_id, prev_screen_func, prev_args = self.screen_history[-1]
            if DEBUG: print(f"[Enroll DEBUG] Going back to screen: {prev_screen_id}. History: {[s[0] for s in self.screen_history]}")
            self.clear_frames(); self.root.update_idletasks(); prev_screen_func(*prev_args)
        elif not (hasattr(self, 'main_frame') and self.main_frame and self.main_frame.winfo_exists()):
             self.start_new_enrollment_process()

    def start_new_enrollment_process(self):
        face_enroll.stop_face_capture()
        self.reset_enrollment_state_full()
        self.screen_history = []
        self.push_screen("step0_id_input", self.show_step0_id_input_screen)

    def create_config_button(self):
        if hasattr(self, 'config_btn_ref') and self.config_btn_ref and self.config_btn_ref.winfo_exists():
            self.config_btn_ref.lift(); return
        self.config_btn_ref = ctk.CTkButton(self.root, text="Cài đặt",
                                            command=self.confirm_reconfigure_mqtt,
                                            width=130, height=35,
                                            fg_color="#6c757d", hover_color="#5a6268",
                                            font=("Segoe UI", 12), text_color="white")
        self.config_btn_ref.place(relx=0.99, rely=0.02, anchor="ne")

    def confirm_reconfigure_mqtt(self):
        if messagebox.askyesno("Xác nhận Cấu Hình Lại",
                               "Bạn có chắc muốn cấu hình lại thông tin kết nối MQTT và API Server cho trạm đăng ký này không?\nThao tác này sẽ xóa cấu hình hiện tại.",
                               icon='warning', parent=self.root):
            self.reconfigure_mqtt_station()

    def reconfigure_mqtt_station(self):
        if self.mqtt_manager:
            self.mqtt_manager.disconnect_client(explicit=True)
            self.mqtt_manager = None
            self.update_connection_status(False)
        if os.path.exists(self.config_path):
            try: os.remove(self.config_path)
            except Exception as e_rm_cfg: print(f"[Enroll ERROR] Failed to remove config file during reconfigure: {e_rm_cfg}")
        self.mqtt_config = {}
        self.http_api_token = None
        self.http_api_token_expiry = None
        self.screen_history = []
        self.push_screen("mqtt_config", self.build_mqtt_config_screen)

    def build_mqtt_config_screen(self):
        self.clear_frames(keep_background=False)
        self.main_frame = ctk.CTkFrame(self.root, fg_color=SCREEN_BG_COLOR, corner_radius=10)
        self.main_frame.place(relx=0.5, rely=0.5, anchor="center", relwidth=0.7, relheight=0.65)
        ctk.CTkLabel(self.main_frame, text="CẤU HÌNH KẾT NỐI (MQTT & API SERVER)",
                     font=TITLE_FONT, text_color=ACCENT_COLOR).pack(pady=(PAD_Y_MAIN_CONTAINER + 5, PAD_Y_MAIN_CONTAINER + 5))
        form_frame = ctk.CTkFrame(self.main_frame, fg_color="transparent")
        form_frame.pack(pady=PAD_Y_WIDGET_VERTICAL, padx=PAD_X_SECTION + 10, fill="x")
        def add_cfg_row(parent, label_text, placeholder_text="", default_value=""):
            row_frame = ctk.CTkFrame(parent, fg_color="transparent")
            row_frame.pack(fill="x", pady=PAD_Y_WIDGET_VERTICAL)
            ctk.CTkLabel(row_frame, text=label_text, font=LABEL_FONT, width=170, anchor="w").pack(side="left", padx=(0,5))
            entry_widget = ctk.CTkEntry(row_frame, font=INPUT_FONT, height=ENTRY_HEIGHT, placeholder_text=placeholder_text)
            entry_widget.pack(side="left", expand=True, fill="x")
            if default_value: entry_widget.insert(0, str(default_value))
            return entry_widget
        self.server_entry_cfg = add_cfg_row(form_frame, "Địa chỉ Server (MQTT/API):", "vd: mqtt.example.com", self.mqtt_config.get("broker", ""))
        self.port_entry_cfg = add_cfg_row(form_frame, "Cổng Broker (MQTT):", "vd: 1883", self.mqtt_config.get("port", ""))
        self.http_port_entry_cfg = add_cfg_row(form_frame, "Cổng HTTP (API):", "vd: 8080", self.mqtt_config.get("http_port", ""))
        self.enroll_room_entry_cfg = add_cfg_row(form_frame, "Tên/Vị trí Trạm ĐK:", "vd: Quầy Lễ Tân", self.mqtt_config.get("enroll_station_room", ""))
        button_frame_cfg = ctk.CTkFrame(self.main_frame, fg_color="transparent")
        button_frame_cfg.pack(pady=(PAD_Y_MAIN_CONTAINER + 10, PAD_Y_MAIN_CONTAINER), padx=PAD_X_SECTION, fill="x", side="bottom")
        ctk.CTkButton(button_frame_cfg, text="LƯU & KẾT NỐI", width=MEDIUM_BUTTON_WIDTH+30, height=MEDIUM_BUTTON_HEIGHT,
                      font=BUTTON_FONT, command=self.validate_and_save_mqtt_config,
                      fg_color=ACCENT_COLOR, text_color=BUTTON_FG_TEXT).pack(side="right", padx=PAD_X_WIDGET_HORIZONTAL)

    def validate_and_save_mqtt_config(self):
        broker_val=self.server_entry_cfg.get().strip()
        port_str_val=self.port_entry_cfg.get().strip()
        http_port_str_val=self.http_port_entry_cfg.get().strip()
        station_location_val=self.enroll_room_entry_cfg.get().strip()
        if not all([broker_val, port_str_val, http_port_str_val, station_location_val]):
            messagebox.showerror("Thiếu Thông Tin", "Vui lòng điền đầy đủ tất cả các trường cấu hình.", parent=self.main_frame or self.root); return
        try:
            mqtt_port_val = int(port_str_val)
            api_http_port_val = int(http_port_str_val)
            if not (0 < mqtt_port_val < 65536 and 0 < api_http_port_val < 65536):
                raise ValueError("Port number out of valid range (1-65535)")
        except ValueError:
            messagebox.showerror("Lỗi Dữ Liệu", "Cổng MQTT hoặc HTTP không hợp lệ.\nPhải là một số trong khoảng 1-65535.", parent=self.main_frame or self.root); return
        new_mqtt_config = {
            "broker": broker_val, "port": mqtt_port_val,
            "http_port": api_http_port_val, "enroll_station_room": station_location_val
        }
        try:
            with open(self.config_path, "w") as f: json.dump(new_mqtt_config, f, indent=2)
            self.mqtt_config = new_mqtt_config
            self.http_api_token = None; self.http_api_token_expiry = None
            if DEBUG: print("[Enroll DEBUG] Saved new MQTT/API configuration:", self.mqtt_config)
        except Exception as e_save_cfg:
            messagebox.showerror("Lỗi Lưu Trữ", f"Không thể lưu file cấu hình: {e_save_cfg}", parent=self.main_frame or self.root); return
        self.show_connecting_screen_mqtt_station()
        self.root.after(200, self._init_mqtt_after_save_config)

    def _init_mqtt_after_save_config(self):
        self._create_and_init_mqtt_manager()
        self.root.after(3000, self.start_new_enrollment_process)

    def show_connecting_screen_mqtt_station(self):
        self.clear_frames(keep_background=False)
        self.main_frame = ctk.CTkFrame(self.root, fg_color=SCREEN_BG_COLOR, corner_radius=10)
        self.main_frame.place(relx=0.5, rely=0.5, anchor="center")
        ctk.CTkLabel(self.main_frame, text="Đang kết nối đến MQTT Server...",
                     font=STEP_TITLE_FONT, text_color=ACCENT_COLOR).pack(pady=20, padx=40)
        progress_bar = ctk.CTkProgressBar(self.main_frame, width=300, height=18, corner_radius=8, mode="indeterminate")
        progress_bar.pack(pady=(0,20), padx=40); progress_bar.start()

    def show_step0_id_input_screen(self):
        self.clear_frames()
        self.main_frame = ctk.CTkFrame(self.root, fg_color=SCREEN_BG_COLOR, corner_radius=10)
        self.main_frame.place(relx=0.5, rely=0.4, anchor="center", relwidth=0.6, relheight=0.4)
        ctk.CTkLabel(self.main_frame, text="LẤY LỊCH LÀM VIỆC", font=TITLE_FONT, text_color=ACCENT_COLOR).pack(pady=(PAD_Y_MAIN_CONTAINER + 5, PAD_Y_MAIN_CONTAINER))
        ctk.CTkLabel(self.main_frame, text="Nhập số CCCD/Mã định danh:", font=LABEL_FONT).pack(pady=(10,2))
        self.cccd_entry_s0 = ctk.CTkEntry(self.main_frame, font=INPUT_FONT, height=ENTRY_HEIGHT, width=300)
        self.cccd_entry_s0.pack(pady=(0, 20)); self.cccd_entry_s0.insert(0, self.current_cccd_for_schedule)
        self.fetch_schedule_button_s0 = ctk.CTkButton(self.main_frame, text="KIỂM TRA LỊCH", font=BUTTON_FONT,
                                           width=MEDIUM_BUTTON_WIDTH, height=MEDIUM_BUTTON_HEIGHT,
                                           command=self.action_fetch_schedule,
                                           fg_color=ACCENT_COLOR, text_color=BUTTON_FG_TEXT)
        self.fetch_schedule_button_s0.pack(pady=(10, 20))
        if len(self.screen_history) > 1 and self.screen_history[-2][0] == "mqtt_config":
             ctk.CTkButton(self.main_frame, text="QUAY LẠI CẤU HÌNH", font=("Segoe UI", 16),
                           width=MEDIUM_BUTTON_WIDTH, height=MEDIUM_BUTTON_HEIGHT-10,
                           command=self.go_back, fg_color="#A0A0A0").pack(pady=(0,10), side="bottom")

    def show_step1_basic_info_screen(self): # This screen is now largely bypassed
        self.clear_frames()
        if not self.current_bio_id: self.generate_new_bio_id()
        if not self.fetched_schedule_data:
            messagebox.showwarning("Thiếu Lịch Làm Việc", "Vui lòng thực hiện Bước 0.", parent=self.root)
            self.push_screen("step0_id_input", self.show_step0_id_input_screen); return

        # THIS SCREEN IS BYPASSED. If it were to be shown, it would display pre-filled, disabled info.
        # For now, the logic in action_fetch_schedule directly pushes to step2.
        # If you need a modified Step 1 (e.g., only to select a room if still necessary),
        # this function would need to be adapted and called.
        if DEBUG: print("[Enroll DEBUG] show_step1_basic_info_screen was called, but it should be bypassed. Navigating to Step 2.")
        self.push_screen("step2_biometrics", self.show_step2_biometric_screen)


    def go_back_to_step0_from_step1(self): # This might not be needed if Step 1 is fully skipped
        if self.screen_history and self.screen_history[-1][0] == "step1_basic_info":
            self.screen_history.pop()
            if self.screen_history and self.screen_history[-1][0] == "step0_id_input":
                 prev_screen_id, prev_screen_func, prev_args = self.screen_history[-1]
                 if DEBUG: print(f"[Enroll DEBUG] Going back to screen: {prev_screen_id} from Step 1.")
                 self.clear_frames(); self.root.update_idletasks(); prev_screen_func(*prev_args)
                 return
        self.push_screen("step0_id_input", self.show_step0_id_input_screen)

    def _create_datetime_pickers(self, parent_frame, datetime_prefix, state="normal"):
        parent_frame.columnconfigure((0,2,4,6,8), weight=0); parent_frame.columnconfigure((1,3,5,7,9), weight=0)
        opt_menu_w_s, opt_menu_w_m, opt_menu_h = OPTION_MENU_WIDTH_S, OPTION_MENU_WIDTH_M, OPTION_MENU_HEIGHT
        opt_fnt, opt_drp_fnt, opt_cr = OPTION_MENU_FONT, OPTION_MENU_DROPDOWN_FONT, 6
        h_var=ctk.StringVar(value=getattr(self,f"{datetime_prefix}_hour_str","00"))
        om_h=ctk.CTkOptionMenu(parent_frame,variable=h_var,values=get_hour_values(),width=opt_menu_w_s,height=opt_menu_h,font=opt_fnt,dropdown_font=opt_drp_fnt,corner_radius=opt_cr, state=state)
        om_h.grid(row=0,column=0,padx=(0,1), pady=1); ctk.CTkLabel(parent_frame,text=":",font=LABEL_FONT).grid(row=0,column=1)
        m_var=ctk.StringVar(value=getattr(self,f"{datetime_prefix}_minute_str","00"))
        om_m=ctk.CTkOptionMenu(parent_frame,variable=m_var,values=get_minute_second_values(),width=opt_menu_w_s,height=opt_menu_h,font=opt_fnt,dropdown_font=opt_drp_fnt,corner_radius=opt_cr, state=state)
        om_m.grid(row=0,column=2,padx=1, pady=1); ctk.CTkLabel(parent_frame,text=":",font=LABEL_FONT).grid(row=0,column=3)
        s_var=ctk.StringVar(value=getattr(self,f"{datetime_prefix}_second_str","00"))
        om_s=ctk.CTkOptionMenu(parent_frame,variable=s_var,values=get_minute_second_values(),width=opt_menu_w_s,height=opt_menu_h,font=opt_fnt,dropdown_font=opt_drp_fnt,corner_radius=opt_cr, state=state)
        om_s.grid(row=0,column=4,padx=(1,4), pady=1)
        date_picker_row_idx, date_picker_col_offset = 0, 5
        year_var=ctk.StringVar(value=getattr(self,f"{datetime_prefix}_year_str",datetime.now().strftime("%Y")))
        month_var=ctk.StringVar(value=getattr(self,f"{datetime_prefix}_month_str",datetime.now().strftime("%m")))
        day_var=ctk.StringVar(value=getattr(self,f"{datetime_prefix}_day_str",datetime.now().strftime("%d")))
        day_values_list=get_day_values(year_var.get(),month_var.get())
        if day_var.get() not in day_values_list: day_var.set(day_values_list[0] if day_values_list else "01")
        om_day_picker=ctk.CTkOptionMenu(parent_frame,variable=day_var,values=day_values_list,width=opt_menu_w_s,height=opt_menu_h,font=opt_fnt,dropdown_font=opt_drp_fnt,corner_radius=opt_cr, state=state)
        om_day_picker.grid(row=date_picker_row_idx,column=date_picker_col_offset,padx=(0,1), pady=1); ctk.CTkLabel(parent_frame,text="/",font=LABEL_FONT).grid(row=date_picker_row_idx,column=date_picker_col_offset+1)
        om_month_picker=ctk.CTkOptionMenu(parent_frame,variable=month_var,values=get_month_values(),width=opt_menu_w_s,height=opt_menu_h,font=opt_fnt,dropdown_font=opt_drp_fnt,corner_radius=opt_cr,
                                    command=lambda _:self._update_days_for_picker(datetime_prefix,day_var,year_var.get(),month_var.get(),om_day_picker), state=state)
        om_month_picker.grid(row=date_picker_row_idx,column=date_picker_col_offset+2,padx=1, pady=1); ctk.CTkLabel(parent_frame,text="/",font=LABEL_FONT).grid(row=date_picker_row_idx,column=date_picker_col_offset+3)
        om_year_picker=ctk.CTkOptionMenu(parent_frame,variable=year_var,values=get_year_values(),width=opt_menu_w_m,height=opt_menu_h,font=opt_fnt,dropdown_font=opt_drp_fnt,corner_radius=opt_cr,
                                   command=lambda _:self._update_days_for_picker(datetime_prefix,day_var,year_var.get(),month_var.get(),om_day_picker), state=state)
        om_year_picker.grid(row=date_picker_row_idx,column=date_picker_col_offset+4,padx=1, pady=1)
        if datetime_prefix == "from":
            self.from_hour_var, self.from_min_var, self.from_sec_var = h_var, m_var, s_var
            self.from_day_var, self.from_month_var, self.from_year_var = day_var, month_var, year_var
            self.from_day_optionmenu = om_day_picker
        else:
            self.to_hour_var, self.to_min_var, self.to_sec_var = h_var, m_var, s_var
            self.to_day_var, self.to_month_var, self.to_year_var = day_var, month_var, year_var
            self.to_day_optionmenu = om_day_picker
    
    def _update_days_for_picker(self, datetime_prefix, day_strvar_ref, year_val_str, month_val_str, day_optionmenu_widget_ref):
        if not (day_optionmenu_widget_ref and day_optionmenu_widget_ref.winfo_exists()): return
        if day_optionmenu_widget_ref.cget("state") == "disabled": return
        new_day_options = get_day_values(year_val_str, month_val_str)
        current_selected_day = day_strvar_ref.get()
        day_optionmenu_widget_ref.configure(values=new_day_options)
        if current_selected_day in new_day_options: day_strvar_ref.set(current_selected_day)
        elif new_day_options: day_strvar_ref.set(new_day_options[0])
        else: day_strvar_ref.set("01")
        if datetime_prefix == "from": self.from_year_str, self.from_month_str = year_val_str, month_val_str
        else: self.to_year_str, self.to_month_str = year_val_str, month_val_str

    def _save_step1_data(self): # Largely bypassed, person_name is set in action_fetch_schedule
        # self.current_person_name is already set from schedule data if flow is Step0->Step2
        # self.current_room_name_selected is not actively set if Step 1 is skipped
        return True

    def _action_goto_step2(self): # This would be called if Step 1 was shown
        # self.current_person_name should be populated from fetched_schedule_data
        if not self.current_person_name: # Check if person name was derived
            messagebox.showerror("Thiếu Thông Tin", "Không thể xác định tên người dùng từ lịch.", parent=self.main_frame or self.root); return
        # No need to save from Step 1 UI if it's bypassed
        self.push_screen("step2_biometrics", self.show_step2_biometric_screen)
    
    def _validate_datetime_logic(self): # Less critical if datetimes are from API
        try:
            required_vars_exist = all(hasattr(self, f"{p}_{c}_str") # Check _str vars now
                                      for p in ["from", "to"] 
                                      for c in ["year", "month", "day", "hour", "minute", "second"])
            if not required_vars_exist:
                messagebox.showerror("Lỗi Dữ Liệu", "Thông tin ngày giờ chưa được tải đầy đủ.", parent=self.main_frame or self.root); return False

            from_datetime_str = f"{self.from_year_str}-{self.from_month_str}-{self.from_day_str} {self.from_hour_str}:{self.from_minute_str}:{self.from_second_str}"
            to_datetime_str = f"{self.to_year_str}-{self.to_month_str}-{self.to_day_str} {self.to_hour_str}:{self.to_minute_str}:{self.to_second_str}"
            from_datetime_object = datetime.strptime(from_datetime_str, "%Y-%m-%d %H:%M:%S")
            to_datetime_object = datetime.strptime(to_datetime_str, "%Y-%m-%d %H:%M:%S")
            if to_datetime_object <= from_datetime_object: 
                messagebox.showerror("Lỗi Thời Gian", "Thời gian 'Đến' (từ API) phải sau thời gian 'Từ'.", parent=self.main_frame or self.root); return False
        except (ValueError, AttributeError) as e_datetime_val: 
            messagebox.showerror("Lỗi Định Dạng Thời Gian", f"Ngày hoặc giờ từ API không hợp lệ: {e_datetime_val}", parent=self.main_frame or self.root); return False
        return True

    def show_step2_biometric_screen(self):
        self.clear_frames()
        if not self.fetched_schedule_data: # Ensure schedule data is present before showing Step 2
            messagebox.showerror("Lỗi Luồng", "Không có dữ liệu lịch. Quay lại Bước 0.", parent=self.root)
            self.push_screen("step0_id_input", self.show_step0_id_input_screen)
            return

        self.main_frame = ctk.CTkFrame(self.root, fg_color=SCREEN_BG_COLOR, corner_radius=10)
        self.main_frame.place(relx=0.5, rely=0.47, anchor="center", relwidth=0.9, relheight=0.75)
        ctk.CTkLabel(self.main_frame, text="ĐĂNG KÝ SINH TRẮC HỌC", font=TITLE_FONT, text_color=ACCENT_COLOR).pack(pady=(PAD_Y_MAIN_CONTAINER, PAD_Y_MAIN_CONTAINER-5))
        
        person_id_for_display = self.fetched_schedule_data.get("idNumber", "N/A")
        # self.current_person_name should have been set in action_fetch_schedule
        person_name_for_display = self.current_person_name or self.fetched_schedule_data.get("scheduleName", "N/A")
        person_info_for_display = f"Đang đăng ký cho: {person_name_for_display[:25]}{'...' if len(person_name_for_display)>25 else ''} (ID: {person_id_for_display})"
        ctk.CTkLabel(self.main_frame, text=person_info_for_display, font=LABEL_FONT).pack(pady=(0, PAD_Y_MAIN_CONTAINER-2))
        
        biometric_buttons_container = ctk.CTkFrame(self.main_frame, fg_color="transparent")
        biometric_buttons_container.pack(expand=True, fill="both", padx=PAD_X_SECTION, pady=0)
        biometric_buttons_container.columnconfigure((0,1,2), weight=1, uniform="bio_button_column_uniform_group") 
        biometric_buttons_container.rowconfigure(0, weight=1)
        button_width_step2 = (WINDOW_WIDTH * 0.94 * 0.3); button_height_step2 = (WINDOW_HEIGHT * 0.81 * 0.55); button_border_spacing_val = 8 
        def create_biometric_button_with_status(parent, grid_column, icon_image, button_text, command_func):
            button_frame = ctk.CTkFrame(parent, fg_color="transparent")
            button_frame.grid(row=0, column=grid_column, padx=PAD_X_WIDGET_HORIZONTAL + 2, pady=0, sticky="nsew")
            actual_button = ctk.CTkButton(button_frame, image=icon_image, text=button_text, font=BUTTON_FONT, compound="top", width=button_width_step2, height=button_height_step2, command=command_func, corner_radius=10, border_spacing=button_border_spacing_val)
            actual_button.pack(expand=True, pady=(5,0))
            status_display_label = ctk.CTkLabel(button_frame, text="", font=SMALL_STATUS_FONT); status_display_label.pack(pady=(2,5))
            return actual_button, status_display_label
        self.face_enroll_btn_s2, self.face_status_label_s2 = create_biometric_button_with_status(biometric_buttons_container, 0, self.face_icon_large, "KHUÔN MẶT", self.start_face_enrollment_s2)
        self.finger_enroll_btn_s2, self.finger_status_label_s2 = create_biometric_button_with_status(biometric_buttons_container, 1, self.fingerprint_icon_large, "VÂN TAY", self.start_fingerprint_enrollment_s2)
        self.rfid_enroll_btn_s2, self.rfid_status_label_s2 = create_biometric_button_with_status(biometric_buttons_container, 2, self.rfid_icon_large, "THẺ RFID/IDCARD", self.start_rfid_enrollment_s2)
        self._update_biometric_status_s2()
        if hasattr(self, 'nav_frame') and self.nav_frame and self.nav_frame.winfo_exists(): self.nav_frame.destroy()
        self.nav_frame = ctk.CTkFrame(self.root, fg_color=BG_COLOR)
        self.nav_frame.place(relx=0.5, rely=1.0, anchor="s", relwidth=1.0, relheight=0.12)
        ctk.CTkButton(self.nav_frame, text="QUAY LẠI (B0)", font=BUTTON_FONT, width=LARGE_BUTTON_WIDTH, height=LARGE_BUTTON_HEIGHT, command=self.go_back, image=self.back_icon, compound="left", corner_radius=8, fg_color="#A0A0A0").pack(side="left", pady=(5,8), padx=PAD_X_MAIN_CONTAINER)
        self.next_step3_button = ctk.CTkButton(self.nav_frame, text="TIẾP TỤC", font=BUTTON_FONT, width=LARGE_BUTTON_WIDTH, height=LARGE_BUTTON_HEIGHT, command=self._action_goto_step3, fg_color=ACCENT_COLOR, text_color=BUTTON_FG_TEXT, image=self.next_icon, compound="right", corner_radius=8)
        self.next_step3_button.pack(side="right", pady=(5,8), padx=PAD_X_MAIN_CONTAINER); self._update_next_button_step2_state()

    def _update_biometric_status_s2(self): 
        enrollment_options = [
            (self.face_enroll_btn_s2, self.face_status_label_s2, "current_face_template_b64"),
            (self.finger_enroll_btn_s2, self.finger_status_label_s2, "current_finger_template_b64"),
            (self.rfid_enroll_btn_s2, self.rfid_status_label_s2, "current_rfid_uid_str")]
        for button_widget, status_label_widget, template_attribute_name in enrollment_options:
            if hasattr(status_label_widget,'winfo_exists') and status_label_widget.winfo_exists(): 
                is_data_enrolled = bool(getattr(self, template_attribute_name, None))
                status_label_widget.configure(text="Đã đăng ký" if is_data_enrolled else "Chưa đăng ký", text_color=SUCCESS_COLOR if is_data_enrolled else "grey50")
                if hasattr(button_widget, 'winfo_exists') and button_widget.winfo_exists():
                     button_widget.configure(fg_color=SUCCESS_COLOR if is_data_enrolled else "#606060", hover_color="#2b9e4c" if is_data_enrolled else "#707070")
        self._update_next_button_step2_state()

    def _update_next_button_step2_state(self): 
         if hasattr(self, 'next_step3_button') and self.next_step3_button.winfo_exists():
            can_proceed_to_step3 = bool(self.current_face_template_b64 or self.current_finger_template_b64 or self.current_rfid_uid_str)
            self.next_step3_button.configure(state="normal" if can_proceed_to_step3 else "disabled", fg_color=ACCENT_COLOR if can_proceed_to_step3 else "#A0A0A0")
   
    def start_face_enrollment_s2(self): face_enroll.capture_face_for_enrollment(parent=self.root, on_success_callback=self.handle_face_enroll_success_s2, on_cancel_callback=self.handle_face_enroll_cancel_s2)
    def handle_face_enroll_success_s2(self, captured_image_b64, face_template_b64): self.current_face_image_b64 = captured_image_b64; self.current_face_template_b64 = face_template_b64; self._schedule_return_to_step2()
    def handle_face_enroll_cancel_s2(self): self._schedule_return_to_step2()
    def start_fingerprint_enrollment_s2(self):
        parent_for_messages = self.main_frame or self.root
        if not self.fingerprint_sensor: messagebox.showerror("Lỗi Cảm Biến", "Cảm biến vân tay lỗi hoặc chưa được khởi tạo.", parent=parent_for_messages); return
        try:
            if not self.fingerprint_sensor.verifyPassword(): messagebox.showerror("Lỗi Cảm Biến", "Không thể xác thực với cảm biến Vân tay. Kiểm tra kết nối.", parent=parent_for_messages); return
        except Exception as e_fp_comm: messagebox.showerror("Lỗi Cảm Biến", f"Lỗi giao tiếp với cảm biến Vân tay: {str(e_fp_comm)[:100]}", parent=parent_for_messages); return
        fingerprint_enroll.enroll_fingerprint_template(parent=self.root, sensor=self.fingerprint_sensor, on_success_callback=self.handle_finger_enroll_success_s2, on_failure_callback=self.handle_finger_enroll_failure_s2, on_cancel_callback=self.handle_finger_enroll_cancel_s2)
    def handle_finger_enroll_success_s2(self, finger_template_b64): self.current_finger_template_b64 = finger_template_b64; self._schedule_return_to_step2()
    def handle_finger_enroll_failure_s2(self, failure_reason=""): messagebox.showerror("Lỗi Đăng Ký Vân Tay", f"Đăng ký vân tay không thành công: {failure_reason}", parent=self.root); self._schedule_return_to_step2()
    def handle_finger_enroll_cancel_s2(self): self._schedule_return_to_step2()
    def start_rfid_enrollment_s2(self):
        parent_for_messages = self.main_frame or self.root
        if not self.rfid_sensor: messagebox.showerror("Lỗi Đầu Đọc", "Đầu đọc RFID/IDCard lỗi hoặc chưa được khởi tạo.", parent=parent_for_messages); return
        try: self.rfid_sensor.SAM_configuration()
        except Exception as e_rfid_comm: messagebox.showerror("Lỗi Đầu Đọc", f"Lỗi giao tiếp với đầu đọc RFID/IDCard: {str(e_rfid_comm)[:80]}", parent=parent_for_messages); return
        rfid_enroll.enroll_rfid_card(parent=self.root, sensor_pn532=self.rfid_sensor, on_success_callback=self.handle_rfid_enroll_success_s2, on_failure_callback=self.handle_rfid_enroll_failure_s2, on_cancel_callback=self.handle_rfid_enroll_cancel_s2)
    def handle_rfid_enroll_success_s2(self, rfid_uid_hex_string): self.current_rfid_uid_str = rfid_uid_hex_string; self._schedule_return_to_step2()
    def handle_rfid_enroll_failure_s2(self, failure_reason=""): messagebox.showerror("Lỗi Đăng Ký RFID/IDCard", f"Đăng ký thẻ không thành công: {failure_reason}", parent=self.root); self._schedule_return_to_step2()
    def handle_rfid_enroll_cancel_s2(self): self._schedule_return_to_step2()
    def _schedule_return_to_step2(self): self.root.after(10, lambda: self.push_screen("step2_biometrics", self.show_step2_biometric_screen))
    def _action_goto_step3(self): 
        if not (self.current_face_template_b64 or self.current_finger_template_b64 or self.current_rfid_uid_str):
            messagebox.showwarning("Thiếu Sinh Trắc Học", "Cần đăng ký ít nhất một mẫu sinh trắc học (Khuôn mặt, Vân tay, hoặc Thẻ RFID/IDCard) để tiếp tục.", parent=self.main_frame or self.root); return
        self.push_screen("step3_confirmation", self.show_step3_confirmation_screen)

    def show_step3_confirmation_screen(self):
        self.clear_frames()
        if not self.fetched_schedule_data: # Ensure schedule data is present
            messagebox.showerror("Lỗi Luồng", "Không có dữ liệu lịch. Quay lại Bước 0.", parent=self.root)
            self.push_screen("step0_id_input", self.show_step0_id_input_screen)
            return

        self.main_frame = ctk.CTkFrame(self.root, fg_color=SCREEN_BG_COLOR, corner_radius=10)
        self.main_frame.place(relx=0.5, rely=0.47, anchor="center", relwidth=0.9, relheight=0.75)
        ctk.CTkLabel(self.main_frame, text="XÁC NHẬN THÔNG TIN", font=TITLE_FONT, text_color=ACCENT_COLOR).pack(pady=(PAD_Y_MAIN_CONTAINER, PAD_Y_MAIN_CONTAINER - 5))
        personal_validity_outer_frame = ctk.CTkFrame(self.main_frame, fg_color=BG_COLOR, corner_radius=8)
        personal_validity_outer_frame.pack(fill="x", padx=PAD_X_SECTION, pady=(PAD_Y_SECTION, PAD_Y_SECTION + 3))
        ctk.CTkLabel(personal_validity_outer_frame, text="Thông Tin Chung & Thời Gian Hiệu Lực (từ API)", font=STEP_TITLE_FONT, text_color=ACCENT_COLOR, anchor="w").pack(fill="x", padx=12, pady=(8, 5))
        personal_validity_content_frame = ctk.CTkFrame(personal_validity_outer_frame, fg_color="transparent")
        personal_validity_content_frame.pack(fill="x", padx=12, pady=(0, 8)); personal_validity_content_frame.columnconfigure((0,2), weight=1); personal_validity_content_frame.columnconfigure((1,3), weight=2)
        current_display_row_idx = [0] 
        def add_compact_info_row(parent_widget, current_row_list_ref, col_label_idx, col_value_idx, label_text_val, value_text_val, value_font_override=None, value_wraplength=200, value_columnspan=1):
            effective_value_font = value_font_override if value_font_override else INPUT_FONT
            ctk.CTkLabel(parent_widget, text=f"{label_text_val}:", font=LABEL_FONT, anchor="e").grid(row=current_row_list_ref[0], column=col_label_idx, sticky="e", padx=(0,3), pady=2)
            ctk.CTkLabel(parent_widget, text=str(value_text_val) if value_text_val is not None else "N/A", font=effective_value_font, anchor="w", wraplength=value_wraplength).grid(row=current_row_list_ref[0], column=col_value_idx, sticky="w", pady=2, columnspan=value_columnspan)
        person_name_s3 = self.current_person_name or self.fetched_schedule_data.get("scheduleName", "N/A")
        person_id_s3 = self.fetched_schedule_data.get("idNumber", "N/A")
        schedule_name_s3 = self.fetched_schedule_data.get("scheduleName", "N/A")
        department_name_s3 = self.fetched_schedule_data.get("departmentName", "N/A")
        add_compact_info_row(personal_validity_content_frame, current_display_row_idx, 0, 1, "Họ Tên", person_name_s3)
        add_compact_info_row(personal_validity_content_frame, current_display_row_idx, 2, 3, "CCCD/ID (từ API)", person_id_s3)
        current_display_row_idx[0] += 1
        add_compact_info_row(personal_validity_content_frame, current_display_row_idx, 0, 1, "Tên Lịch LV", schedule_name_s3)
        add_compact_info_row(personal_validity_content_frame, current_display_row_idx, 2, 3, "Phòng Ban", department_name_s3)
        current_display_row_idx[0] += 1
        from_display_str = f"{self.from_day_str}/{self.from_month_str}/{self.from_year_str} {self.from_hour_str}:{self.from_minute_str}"
        add_compact_info_row(personal_validity_content_frame, current_display_row_idx, 0, 1, "Hiệu lực từ", from_display_str)
        to_display_str = f"{self.to_day_str}/{self.to_month_str}/{self.to_year_str} {self.to_hour_str}:{self.to_minute_str}"
        add_compact_info_row(personal_validity_content_frame, current_display_row_idx, 2, 3, "Hiệu lực đến", to_display_str)
        current_display_row_idx[0] += 1
        day_names_map = ["Thứ 2", "Thứ 3", "Thứ 4", "Thứ 5", "Thứ 6", "Thứ 7", "Chủ Nhật"]
        active_days_display_list = [day_names_map[i] for i, act in enumerate(self.active_day_mask_list) if act and i < len(day_names_map)]
        active_days_display_str = ", ".join(active_days_display_list) or "Không ngày nào hoạt động"
        add_compact_info_row(personal_validity_content_frame, current_display_row_idx, 0, 1, "Lịch hoạt động", active_days_display_str, value_wraplength=320, value_columnspan=3)
        current_display_row_idx[0] += 1
        bio_outer_frame = ctk.CTkFrame(self.main_frame, fg_color=BG_COLOR, corner_radius=8)
        bio_outer_frame.pack(fill="both", expand=True, padx=PAD_X_SECTION, pady=(PAD_Y_SECTION, PAD_Y_SECTION))
        ctk.CTkLabel(bio_outer_frame, text="Thông Tin Sinh Trắc Học Đã Đăng Ký", font=STEP_TITLE_FONT, text_color=ACCENT_COLOR, anchor="w").pack(fill="x", padx=12, pady=(8, 5))
        bio_content_cols = ctk.CTkFrame(bio_outer_frame, fg_color="transparent")
        bio_content_cols.pack(fill="both", expand=True, padx=5, pady=(0, 8)); bio_content_cols.columnconfigure((0,1,2), weight=1, uniform="bio_info_col_s3_uniform_group"); bio_content_cols.rowconfigure(0, weight=1)
        def create_bio_col_display(parent_widget_for_grid, grid_col_index, bio_type_title, is_enrolled_flag, ctk_image_obj=None, rfid_uid_display_text=None):
            col_content_frame = ctk.CTkFrame(parent_widget_for_grid, fg_color=SCREEN_BG_COLOR, corner_radius=6, border_width=1, border_color="gray70")
            col_content_frame.grid(row=0, column=grid_col_index, sticky="nsew", padx=5, pady=3)
            ctk.CTkLabel(col_content_frame, text=bio_type_title, font=LABEL_FONT, text_color=ACCENT_COLOR).pack(pady=(8,3))
            status_text_val = "ĐÃ ĐĂNG KÝ" if is_enrolled_flag else "CHƯA ĐĂNG KÝ"; status_text_color_val = SUCCESS_COLOR if is_enrolled_flag else WARNING_COLOR
            ctk.CTkLabel(col_content_frame, text=status_text_val, font=INPUT_FONT, text_color=status_text_color_val).pack(pady=(0,8))
            if is_enrolled_flag:
                if bio_type_title == "Khuôn Mặt" and ctk_image_obj: ctk.CTkLabel(col_content_frame, image=ctk_image_obj, text="").pack(pady=(0,8),expand=True,anchor="center")
                elif bio_type_title == "Thẻ RFID/IDCard" and rfid_uid_display_text: ctk.CTkLabel(col_content_frame, text=str(rfid_uid_display_text), font=("Segoe UI", 13, "italic"), text_color="gray20").pack(pady=(0,8))
        self.preview_face_image_ctk_s3_obj = None
        if self.current_face_image_b64:
            try:
                img_bytes = base64.b64decode(self.current_face_image_b64); pil_image_face = Image.open(io.BytesIO(img_bytes))
                preview_dimensions = (70,70); pil_image_face.thumbnail(preview_dimensions, Image.Resampling.LANCZOS)
                final_pil_preview = Image.new("RGBA", preview_dimensions, (0,0,0,0)) 
                paste_x_coord = (preview_dimensions[0] - pil_image_face.width) // 2; paste_y_coord = (preview_dimensions[1] - pil_image_face.height) // 2
                final_pil_preview.paste(pil_image_face, (paste_x_coord, paste_y_coord))
                self.preview_face_image_ctk_s3_obj = CTkImage(light_image=final_pil_preview,dark_image=final_pil_preview,size=preview_dimensions)
            except Exception as e_face_preview: print(f"[Enroll ERROR] Creating face preview for Step 3: {e_face_preview}")
        create_bio_col_display(bio_content_cols, 0, "Khuôn Mặt", bool(self.current_face_template_b64), self.preview_face_image_ctk_s3_obj)
        create_bio_col_display(bio_content_cols, 1, "Vân Tay", bool(self.current_finger_template_b64))
        rfid_uid_text = f"UID: {self.current_rfid_uid_str}" if self.current_rfid_uid_str else None
        create_bio_col_display(bio_content_cols, 2, "Thẻ RFID/IDCard", bool(self.current_rfid_uid_str), rfid_uid_display_text=rfid_uid_text)
        if hasattr(self, 'nav_frame') and self.nav_frame and self.nav_frame.winfo_exists(): self.nav_frame.destroy()
        self.nav_frame = ctk.CTkFrame(self.root, fg_color=BG_COLOR)
        self.nav_frame.place(relx=0.5, rely=1.0, anchor="s", relwidth=1.0, relheight=0.12)
        ctk.CTkButton(self.nav_frame, text="SỬA SINH TRẮC (B2)", font=BUTTON_FONT, width=LARGE_BUTTON_WIDTH, height=LARGE_BUTTON_HEIGHT, command=self._action_goto_step2_from_step3, image=self.back_icon, compound="left", corner_radius=8, fg_color="#A0A0A0").pack(side="left", pady=(5,8), padx=PAD_X_MAIN_CONTAINER)
        ctk.CTkButton(self.nav_frame, text="GỬI ĐĂNG KÝ (HTTP)", font=BUTTON_FONT, width=LARGE_BUTTON_WIDTH + 20, height=LARGE_BUTTON_HEIGHT, command=self.prepare_and_send_data_http, fg_color=SUCCESS_COLOR, text_color=BUTTON_FG_TEXT, image=self.send_icon_large, compound="right", corner_radius=8).pack(side="right", pady=(5,8), padx=PAD_X_MAIN_CONTAINER)

    def _action_goto_step2_from_step3(self):
        if self.screen_history and self.screen_history[-1][0] == "step3_confirmation":
            self.screen_history.pop()
            if self.screen_history and self.screen_history[-1][0] == "step2_biometrics":
                prev_screen_id, prev_screen_func, prev_args = self.screen_history[-1]
                self.clear_frames(); self.root.update_idletasks(); prev_screen_func(*prev_args)
                return
        self.push_screen("step2_biometrics", self.show_step2_biometric_screen)

    def _action_goto_step0_from_step3(self):
        self.reset_enrollment_state_full()
        self.screen_history = []
        self.push_screen("step0_id_input", self.show_step0_id_input_screen)

    def generate_active_days_mask_from_list(self):
        mask = ['0'] * 7
        for i, is_active in enumerate(self.active_day_mask_list):
            if i < 7 and is_active: mask[i] = '1'
        return "".join(mask)

    def prepare_and_send_data(self):
        parent_for_messages = self.main_frame or self.root
        if DEBUG: print("[Enroll DEBUG] prepare_and_send_data (MQTT) called - THIS IS OBSOLETE FOR NEW HTTP FLOW.")
        if not self.current_room_name_selected:
            messagebox.showerror("Lỗi Thiếu Thông Tin", "Vui lòng chọn một phòng đăng ký tại Bước 1 (cho MQTT).", parent=parent_for_messages); return
        target_device_mac = self.discovered_rooms_macs.get(self.current_room_name_selected)
        if not target_device_mac:
            messagebox.showerror("Lỗi Phòng Đăng Ký", f"Không tìm thấy địa chỉ MAC cho phòng '{self.current_room_name_selected}' (cho MQTT).", parent=parent_for_messages); return
        id_num_to_send = self.current_id_number
        if self.fetched_schedule_data and self.fetched_schedule_data.get("idNumber"): # Prefer ID from API
             id_num_to_send = self.fetched_schedule_data.get("idNumber")
        if not all([id_num_to_send, self.current_person_name]):
            messagebox.showerror("Lỗi Thiếu Thông Tin", "Vui lòng nhập Họ Tên và Số CCCD/Mã ID.", parent=parent_for_messages); return
        if not (self.current_face_template_b64 or self.current_finger_template_b64 or self.current_rfid_uid_str):
            messagebox.showwarning("Lỗi Thiếu Sinh Trắc Học", "Cần đăng ký ít nhất một mẫu sinh trắc học.", parent=parent_for_messages)
            self.push_screen("step2_biometrics", self.show_step2_biometric_screen); return
        biometric_data_list_for_payload = []
        if self.current_face_template_b64:
            if not self.current_face_image_b64: messagebox.showerror("Lỗi Dữ Liệu Khuôn Mặt", "Dữ liệu khuôn mặt không đầy đủ.", parent=parent_for_messages); return
            biometric_data_list_for_payload.append({"BioType": "FACE", "Template": self.current_face_template_b64, "Img": self.current_face_image_b64})
        if self.current_finger_template_b64: biometric_data_list_for_payload.append({"BioType": "FINGER", "Template": self.current_finger_template_b64})
        if self.current_rfid_uid_str: biometric_data_list_for_payload.append({"BioType": "IDCARD", "Template": self.current_rfid_uid_str})
        from_date_iso_str = f"{self.from_year_str}-{self.from_month_str}-{self.from_day_str}"; from_time_iso_str = f"{self.from_hour_str}:{self.from_minute_str}:{self.from_second_str}"
        to_date_iso_str = f"{self.to_year_str}-{self.to_month_str}-{self.to_day_str}"; to_time_iso_str = f"{self.to_hour_str}:{self.to_minute_str}:{self.to_second_str}"
        final_enrollment_payload = {
            "bioId": self.current_bio_id, "idNumber": id_num_to_send, "personName": self.current_person_name,
            "cmdType": "PUSH_NEW_BIO", "bioDatas": biometric_data_list_for_payload,
            "fromDate": from_date_iso_str, "toDate": to_date_iso_str, 
            "fromTime": from_time_iso_str, "toTime": to_time_iso_str,
            "activeDays": self.generate_active_days_mask_from_list()
        }
        if self.mqtt_manager:
            was_published_directly = self.mqtt_manager.publish_enrollment_payload([final_enrollment_payload], target_device_mac)
            if self.mqtt_manager.is_actively_connected() and was_published_directly:
                messagebox.showinfo("Gửi Thành Công (MQTT)", f"Đã gửi dữ liệu đăng ký (MQTT) cho '{self.current_person_name}' đến '{self.current_room_name_selected}'. (LUỒNG CŨ)", parent=self.root)
            elif not was_published_directly:
                 messagebox.showinfo("Đã Xếp Hàng Đợi (MQTT)", f"Dữ liệu (MQTT) cho '{self.current_person_name}' đã xếp hàng đợi để gửi đến '{self.current_room_name_selected}'. (LUỒNG CŨ)", parent=self.root)
            self.start_new_enrollment_process()
        else: messagebox.showerror("Lỗi Kết Nối MQTT", "MQTT Manager chưa sẵn sàng. Không thể gửi dữ liệu (MQTT).", parent=self.root)

    def reset_enrollment_state_full(self):
        self.generate_new_bio_id()
        self.fetched_schedule_data = None
        self.current_cccd_for_schedule = ""
        self.current_id_number = ""; self.current_person_name = ""; self.current_room_name_selected = None
        now_datetime = datetime.now()
        self.from_hour_str = "00"; self.from_minute_str = "00"; self.from_second_str = "00"
        self.from_day_str = now_datetime.strftime("%d"); self.from_month_str = now_datetime.strftime("%m"); self.from_year_str = now_datetime.strftime("%Y")
        to_datetime_default = now_datetime + timedelta(days=6) 
        self.to_hour_str = "23"; self.to_minute_str = "59"; self.to_second_str = "59"
        self.to_day_str = to_datetime_default.strftime("%d"); self.to_month_str = to_datetime_default.strftime("%m"); self.to_year_str = to_datetime_default.strftime("%Y")
        self.active_day_mask_list = [True] * 7
        self.current_face_image_b64 = None; self.current_face_template_b64 = None
        self.current_finger_template_b64 = None; self.current_rfid_uid_str = None
        self.preview_face_image_ctk = None
        if DEBUG: print("[Enroll DEBUG] Enrollment state fully reset for new session.")

    def cleanup(self):
        if DEBUG: print("[Enroll INFO] Application cleanup process started...")
        face_enroll.stop_face_capture()
        if self.mqtt_manager:
            if DEBUG: print("[Enroll INFO] Explicitly disconnecting MQTT client...")
            self.mqtt_manager.disconnect_client(explicit=True)
        if self.root and self.root.winfo_exists(): self.root.destroy()
        if DEBUG: print("[Enroll INFO] Application cleanup finished.")

if __name__ == "__main__":
    try:
        from ctypes import windll
        windll.shcore.SetProcessDpiAwareness(1)
    except Exception: pass
    ctk.set_appearance_mode("Light")
    ctk.set_default_color_theme("blue")
    root = ctk.CTk()
    root.geometry(f"{WINDOW_WIDTH}x{WINDOW_HEIGHT}")
    root.title("Trạm Đăng Ký Sinh Trắc Học - Navis SmartLock")
    app = EnrollmentApp(root)
    root.mainloop()